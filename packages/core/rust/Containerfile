FROM scratch AS build
ARG VERSION
ARG TARGETARCH
ARG MRUSTC_VERSION
ENV BOOTSTRAP_RUST_VERSION="1.74"
ENV BOOTSTRAP_GCC_VERSION="15.2.0"
COPY --from=stagex/core-filesystem . /
COPY --from=stagex/core-busybox . /
# As `/bin/bash` is required by `mrustc`, wrap BusyBox's Bourne-inspired shell (`hush`) as `bash`
RUN printf "%s\n%s\n" '#!/bin/sh' 'hush "$@"' > /usr/bin/bash && chmod +x /usr/bin/bash
COPY --from=stagex/core-make . /
COPY --from=stagex/core-python . /
COPY --from=stagex/core-py-setuptools . /
COPY --from=stagex/core-zlib . /
COPY --from=stagex/core-pkgconf . /
COPY --from=stagex/core-openssl . /
COPY --from=stagex/core-libzstd . /
COPY --from=stagex/core-perl . /
COPY --from=stagex/core-curl . /
COPY --from=stagex/core-ca-certificates . /
COPY --from=stagex/core-libffi . /
COPY --from=stagex/core-musl . /
COPY --from=stagex/core-clang-rt-devel . /
COPY --from=stagex/core-libunwind . /
COPY --from=stagex/core-libcxx . /
COPY --from=stagex/core-libcxxabi . /
COPY --from=stagex/core-binutils . /
COPY --from=stagex/core-mpfr . /
COPY --from=stagex/core-mpc . /
COPY --from=stagex/core-isl . /
COPY --from=stagex/core-gmp . /
COPY --from=stagex/core-gcc . /
COPY --from=stagex/core-mold . / 
COPY --from=stagex/core-onetbb . /
COPY --from=stagex/core-llvm17 . /
COPY <<-'EOF' /etc/profile
	set -eux
	[[ "$TARGETARCH" == "amd64" ]] && ARCH="x86_64"
	[[ "$TARGETARCH" == "arm64" ]] && ARCH="aarch64"
	export ARCH
	export TARGET=${ARCH}-unknown-linux-musl
	export MAKEFLAGS="-j$(nproc)"
	export LLVM_ROOT="/usr/lib/llvm${LLVM_VERSION}"
	[[ "$LLVM_VERSION" == "system" ]] && LLVM_ROOT="/usr"
	export LLVM_BINDIR=${LLVM_ROOT}/bin
	export LLVM_CONFIG=${LLVM_BINDIR}/llvm-config
EOF
SHELL ["/bin/sh","-l","-c"]

ADD fetch/mrustc-${MRUSTC_VERSION}.tar.gz .
WORKDIR /mrustc-${MRUSTC_VERSION}
COPY fetch/rustc-${BOOTSTRAP_RUST_VERSION}.0-src.tar.gz .
ADD patches/add-missing-std-lib-includes.patch .
ADD patches/fix-lib-linking.patch .
ENV LLVM_VERSION="17"
RUN --network=none <<-EOF
	export RUSTC_VERSION="${BOOTSTRAP_RUST_VERSION}.0"
	export MRUSTC_TARGET_VER="${BOOTSTRAP_RUST_VERSION}"
	export RUSTC_INSTALL_BINDIR="bin"
	export LIBGIT2_SYS_USE_PKG_CONFIG="1"
	export OUTDIR_SUF=
	export CXXFLAGS_EXTRA="-L/usr/lib/gcc/${ARCH}-linux-musl/${BOOTSTRAP_GCC_VERSION}/"
	export RUSTC_TARGET="${TARGET}"
	export CC=/usr/bin/gcc
	export CXX=/usr/bin/g++
	mkdir -p /etc/clang
	echo "--gcc-install-dir=/usr/lib/gcc/${ARCH}-linux-musl/${BOOTSTRAP_GCC_VERSION}/" > /etc/clang/${ARCH}-unknown-linux-musl.cfg
	ln -sf /usr/bin/ld.mold /usr/bin/ld
	patch -p1 < fix-lib-linking.patch
	patch -p1 < add-missing-std-lib-includes.patch
	make
	make RUSTCSRC
	make LIBS
	export CXX="${LLVM_BINDIR}/clang++"
	make -f minicargo.mk LLVM_CONFIG=${LLVM_CONFIG} output/cargo
	make -f minicargo.mk LLVM_CONFIG=${LLVM_CONFIG} output/rustc
	ln -sf /usr/bin/gcc /usr/bin/cc
	make -C run_rustc LLVM_CONFIG=${LLVM_CONFIG}
	mkdir /rust-${RUSTC_VERSION}
	cp -R run_rustc/output/prefix /rust-${RUSTC_VERSION}/usr
EOF

#HACK: We import llvm late because it clobbers binutils tools needed ealier in the build
# remove when binutils tools replaced by llvm are gnu- prefixed by default in package
# This frees up /usr/bin/ld to point at ld.lld by default, etc
COPY --from=stagex/core-llvm . / 
COPY --from=stagex/core-mold . / 
COPY --from=stagex/core-onetbb . /

WORKDIR /

ENV CONFIGURE_FLAGS=
COPY --chmod=0755 <<-'EOF' build
	set -eux
	TARGET_VERSION=${1}
	BUILD_VERSION=${2}
	TOOLS=${3:-cargo}
	PATCHES=${4:-}
	PREFIX=/rust-${TARGET_VERSION}/usr
	BUILD_PREFIX=/rust-${BUILD_VERSION}/usr
	export CC=${LLVM_BINDIR}/clang
	export CXX=${LLVM_BINDIR}/clang++
	export AS=${LLVM_BINDIR}/llvm-as
	export AR=${LLVM_BINDIR}/llvm-ar
	export NM=${LLVM_BINDIR}/llvm-nm
	export DWP=${LLVM_BINDIR}/llvm-dwp
	export RANLIB=${LLVM_BINDIR}/llvm-ranlib
	export READELF=${LLVM_BINDIR}/llvm-readelf
	export STRIP=${LLVM_BINDIR}/llvm-strip
	export OBJCOPY=${LLVM_BINDIR}/llvm-objcopy
	export OBJDUMP=${LLVM_BINDIR}/llvm-objdump
	export SIZE=${LLVM_BINDIR}/llvm-size
	export LIBCC="/usr/lib/clang/${LLVM_VERSION}/lib/${TARGET}/libclang_rt.builtins.a"
	export LDFLAGS="-fuse-ld=/usr/bin/ld.mold"
	ln -sf ${LLVM_BINDIR}/clang++ /usr/bin/c++
	ln -sf ${LLVM_BINDIR}/clang /usr/bin/cc
	ln -sf /usr/bin/mold /usr/bin/ld
	cd rustc-${TARGET_VERSION}-src
	[[ -z "$PATCHES" ]] || for name in ${PATCHES//,/ }; do
		patch -p1 < ../${name}.patch
	done

	# Tune how `rustc` is built for a faster build process.
	#
	# - `embed-bitcode-false` doesn't emit LLVM bitcode with the object files, as unnecessary.
	# - `incremental=false` doesn't build a cache for incremental builds, as unnecessary here.
	RUSTFLAGS="-Clinker=clang -Clink-arg=-Wl,-fuse-ld=mold -Cembed-bitcode=false -Cincremental=false"
	# For intermediary compilers, which aren't part of the committed output, be more aggressive
	if [ ! "$TARGET_VERSION" = "$VERSION" ]; then
		# Enable native codegen
		RUSTFLAGS="$RUSTFLAGS -Ctarget-cpu=native"

		# Set `codegen-units` to `nproc`, which will break reproducible builds as Rust builds are only
		# deterministic with a consistent amount of units.
		RUSTFLAGS="$RUSTFLAGS -Ccodegen-units=$(nproc)"

		# Also, if the compiler is sufficiently modern, enable the threaded frontend. This was available
		# under nightly as soon ~1.75, but we delay enabling it until it was more tested and stable.
		# Note the usage of threads produces a non-deterministic output without flags such as
		# `-Zcodegen-source-order` to sort the outputs after their compilation.
		if [ $(printf "%s" "$BUILD_VERSION" | cut -d'.' -f2) -ge 85 ]; then
			RUSTFLAGS="$RUSTFLAGS -Zthreads=$(nproc)"
		fi
	fi

	./configure \
		--build="${TARGET}" \
		--host="${TARGET}" \
		--target="${TARGET}" \
		--local-rust-root="${BUILD_PREFIX}" \
		--tools="${TOOLS}" \
		--llvm-root="${LLVM_ROOT}" \
		--llvm-libunwind="system" \
		--enable-local-rust \
		--enable-clang \
		--enable-option-checking \
		--enable-locked-deps \
		--enable-vendor \
		--dist-compression-formats=gz \
		--disable-docs \
		--python="python3" \
		--prefix="${PREFIX}/usr" \
		--sysconfdir="${PREFIX}/etc" \
		--release-channel="stable" \
		--set="install.prefix=${PREFIX}" \
		--set="target.${TARGET}.crt-static=false" \
		--set="target.${TARGET}.musl-root=/usr" \
		--set="target.${TARGET}.llvm-config=${LLVM_BINDIR}/llvm-config" \
		--set="rust.optimize=2" \
		--set="rust.lld=false" \
		--set="rust.llvm-tools=false" \
		$CONFIGURE_FLAGS

	if [ ! "${TARGET_VERSION}" = "${VERSION}" ]; then
		# We only build the first-stage Rust compiler, as sufficient for further bootstrapping.
		#
		# We specifically choose `library`, as in, the Rust standard library, as what to build up to.
		#
		# The exception is with more modern compilers, due to the bootstrap sequence changing such that
		# `std` is only built _after_ the stage 1 compiler, requiring building the stage 1 compiler,
		# then `std`, then the stage 2 compiler, then `std` again, to create a functional sysroot.
		#
		# For more context on the changes made, see
		# https:/blog.rust-lang.org/inside-rust/2025/05/29/redesigning-the-initial-bootstrap-sequence.
		STAGE=1
		if [ $(printf "%s" "$TARGET_VERSION" | cut -d'.' -f2) -ge 90 ]; then
			STAGE=2
		fi
		python3 x.py build --stage $STAGE library

		# We also build `cargo`, as required to continue the bootstrap.
		#
		# We specify to build with the prior-stage toolchain, as acceptable, as building with the
		# just-built toolchain causes Rust's bootstrap to try to flush it out _much_ more.
		python3 x.py build --stage $(( $STAGE - 1 )) src/tools/cargo

		# Manually 'install' it
		mkdir -p ${PREFIX}
		mv build/host/stage${STAGE}/* ${PREFIX}/
		mv $(find build/host/ -type f -name "cargo" | head -n1) ${PREFIX}/bin/
	else
		python3 x.py install
	fi

	cd /
	[ "${TARGET_VERSION}" == "${VERSION}" ] || rm -rf rustc-${TARGET_VERSION}-src /rust-${BUILD_VERSION}
EOF

# HACK: Required by Rust 1.75.0
# https://github.com/rust-lang/rust/issues/117885
RUN mkdir -p $HOME/.cargo/registry/src/index.crates.io-6f17d22bba15001f/
ADD fetch/rustc-1.75.0-src.tar.gz .
RUN ./build 1.75.0 1.74.0

ADD fetch/rustc-1.76.0-src.tar.gz .
RUN ./build 1.76.0 1.75.0

ADD fetch/rustc-1.77.0-src.tar.gz .
RUN ./build 1.77.0 1.76.0

ADD fetch/rustc-1.78.0-src.tar.gz .
RUN ./build 1.78.0 1.77.0

ADD fetch/rustc-1.79.0-src.tar.gz .
RUN ./build 1.79.0 1.78.0

ADD fetch/rustc-1.80.0-src.tar.gz .
RUN ./build 1.80.0 1.79.0

ADD fetch/rustc-1.81.0-src.tar.gz .
RUN ./build 1.81.0 1.80.0

ADD fetch/rustc-1.82.0-src.tar.gz .
RUN ./build 1.82.0 1.81.0

ENV LLVM_VERSION="19"
COPY --from=stagex/core-llvm19 . /
ADD fetch/rustc-1.83.0-src.tar.gz .
RUN ./build 1.83.0 1.82.0

ADD fetch/rustc-1.84.0-src.tar.gz .
RUN ./build 1.84.0 1.83.0

ADD fetch/rustc-1.85.0-src.tar.gz .
# HACK: rust 1.85.0 literally cannot build if .git does not exist. No idea why
RUN mkdir -p rustc-1.85.0-src/.git
RUN ./build 1.85.0 1.84.0

ADD fetch/rustc-1.86.0-src.tar.gz .
RUN ./build 1.86.0 1.85.0

ADD fetch/rustc-1.87.0-src.tar.gz .
RUN ./build 1.87.0 1.86.0

ADD fetch/rustc-1.88.0-src.tar.gz .
RUN ./build 1.88.0 1.87.0 ""

ADD fetch/rustc-1.89.0-src.tar.gz .
RUN ./build 1.89.0 1.88.0 ""

ADD fetch/rustc-1.90.0-src.tar.gz .
RUN ./build 1.90.0 1.89.0 ""

ENV LLVM_VERSION="system"

ADD fetch/rustc-1.91.1-src.tar.gz .
RUN ./build 1.91.1 1.90.0 ""

ADD fetch/rustc-1.92.0-src.tar.gz .
RUN ./build 1.92.0 1.91.1 ""

ADD fetch/rustc-1.93.0-src.tar.gz .

# Patch the default for `musl` targets to be dynamically, not statically, linked
RUN <<-EOF
	for file in $(find ./rustc-1.93.0-src/compiler/rustc_target/src/spec/targets/ -type f | grep "musl"); do
		sed -i s/"crt_static_default = true"/"crt_static_default = false"/ $file
	done
EOF

RUN ./build ${VERSION} 1.92.0 cargo,clippy,rustdoc,rustfmt,rust-demangler,src,wasm-component-ld
RUN <<-EOF
	mv /rust-${VERSION} /rootfs
	cd /rootfs/usr/lib/rustlib
	rm install.log
	sort -o manifest-cargo manifest-cargo
	sort -o manifest-rustc manifest-rustc
	sort -o manifest-rust-std-${TARGET} manifest-rust-std-${TARGET}
	rm -f ${TARGET}/lib/self-contained/libunwind.a
EOF

FROM stagex/core-filesystem AS package-rust
COPY --from=build /rootfs/ /
