FROM scratch AS build
ARG VERSION
ARG TARGETARCH
ARG MRUSTC_VERSION
ENV BOOTSTRAP_RUST_VERSION="1.90"
COPY --from=stagex/core-filesystem . /
COPY --from=stagex/core-busybox . /
# As `/bin/bash` is required by `mrustc`, wrap BusyBox's Bourne-inspired shell (`hush`) as `bash`
RUN --network=none printf "%s\n%s\n" '#!/bin/sh' 'hush "$@"' > /usr/bin/bash && chmod +x /usr/bin/bash
COPY --from=stagex/core-make . /
COPY --from=stagex/core-python . /
COPY --from=stagex/core-py-setuptools . /
COPY --from=stagex/core-zlib . /
COPY --from=stagex/core-pkgconf . /
COPY --from=stagex/core-openssl . /
COPY --from=stagex/core-libzstd . /
COPY --from=stagex/core-perl . /
COPY --from=stagex/core-curl . /
COPY --from=stagex/core-ca-certificates . /
COPY --from=stagex/core-libffi . /
COPY --from=stagex/core-musl . /
COPY --from=stagex/core-binutils . /
# `busybox patch` isn't compatible with `mrustc`'s patch files. GNU `patch` is required
COPY --from=stagex/core-patch . /
COPY --from=stagex/core-mpfr . /
COPY --from=stagex/core-mpc . /
COPY --from=stagex/core-isl . /
COPY --from=stagex/core-gmp . /
COPY --from=stagex/core-gcc . /
COPY --from=stagex/core-mold . /
COPY --from=stagex/core-onetbb . /
COPY --from=stagex/core-llvm . /
COPY <<-'EOF' /etc/profile
	set -eux
	[[ "$TARGETARCH" == "amd64" ]] && ARCH="x86_64"
	[[ "$TARGETARCH" == "arm64" ]] && ARCH="aarch64"
	export ARCH
	export TARGET=${ARCH}-unknown-linux-musl
	export MAKEFLAGS="-j$(nproc)"
	export LLVM_ROOT="/usr/lib/llvm${LLVM_VERSION}"
	[[ "$LLVM_VERSION" == "system" ]] && LLVM_ROOT="/usr"
	export LLVM_BINDIR=${LLVM_ROOT}/bin
	export LLVM_CONFIG=${LLVM_BINDIR}/llvm-config
EOF
SHELL ["/bin/sh","-l","-c"]

# Rust defaults to static linking for `musl` targets when we want dynamic linking.
ENV RUSTFLAGS="-Ctarget-feature=-crt-static"

ADD fetch/mrustc-${MRUSTC_VERSION}.tar.gz .
ADD fetch/*.patch .
WORKDIR /mrustc-${MRUSTC_VERSION}
COPY fetch/rustc-${BOOTSTRAP_RUST_VERSION}.0-src.tar.gz .
ENV LLVM_VERSION="system"
RUN --network=none <<-EOF
	export RUSTC_VERSION="${BOOTSTRAP_RUST_VERSION}.0"
	export MRUSTC_TARGET_VER="${BOOTSTRAP_RUST_VERSION}"
	export RUSTC_INSTALL_BINDIR="bin"
	export LIBGIT2_SYS_USE_PKG_CONFIG="1"
	export OUTDIR_SUF=
	export RUSTC_TARGET="${TARGET}"
	export LD="mold"
	# Because `g++` didn't respect `$LD, -fuse-ld=mold`, replace `ld` entirely
	ln -sf /usr/bin/mold /usr/bin/ld
	export LDFLAGS="${LDFLAGS:-} -L/usr/lib"
	export CFLAGS="${CFLAGS:-} -O2 -fuse-ld=mold"
	export CXXFLAGS="${CXXFLAGS:-} -O2 -fuse-ld=mold"
	export CC=clang
	# Remove `gcc`-specific flags since we're using `clang`
	export CCC_OVERRIDE_OPTIONS="x-fno-tree-sra"
	# `g++` is required to build `mrustc` itself due to an issue `clang++` had with `mrustc`'s macros
	export CXX=g++

	# Revert the recently 'optimized' type inference as it segfaults
	patch -p1 --reverse -i ../99d9bd0c788b0c72fc2f4fee6187a462ceb059f2.patch
	# Apply the upstream fixes to `run_rustc`
	patch -p1 -i ../0b8ce630d0cabe07bc42632015c1fe558dc36af8.patch
	patch -p1 -i ../df7034215681d6562afea0ecc3c10847f67d27d7.patch

	# Build `mrustc`
	# We're much more aggressive with optimizing `mrustc` due to how long it takes
	make CXXFLAGS="$CXXFLAGS -O3"
	# Apply `mrustc`'s patches to the `rustc` source so it'll build with `mrustc`
	make RUSTCSRC

	# `mrustc` wants to build the LLVM toolchain vendored within Rust. We don't.
	# Shim `cmake` to a NOP so `mrustc` believes `cmake` worked without issue
	echo "#!/bin/sh" > /usr/bin/cmake
	echo "exit 0" >> /usr/bin/cmake
	chmod +x /usr/bin/cmake
	# Shim the build directory to our existing LLVM toolchain
	ln -s $LLVM_ROOT /mrustc-rust${BOOTSTRAP_RUST_VERSION}_bootstrapped/rustc-${BOOTSTRAP_RUST_VERSION}.0-src/build
	# Stub a `Makefile` so `make` doesn't error when it tries to actually build LLVM (after `cmake`)
	echo "all:" > $LLVM_ROOT/Makefile

	# Compile the Rust standard library
	make -f minicargo.mk LIBS

	# Move to `clang++` now that we're done compiling `mrustc`, as required by some Rust crates
	export CXX="${LLVM_BINDIR}/clang++"

	# `gcc` is required here due to the way some ASM is formatted when compiling `rustix`
	export CC=gcc
	make -f minicargo.mk output/rustc
	make -f minicargo.mk output/cargo
	export CC=clang

	# Build a dynamically-linked `rustc`
	sed -i s/'RUSTFLAGS="'/'RUSTFLAGS="-Ctarget-feature=-crt-static '/ run_rustc/Makefile

	RUN_RUSTC_OUTPUT=/mrustc-rust${BOOTSTRAP_RUST_VERSION}_bootstrapped/run_rustc/output
	# Populate what will be Rust's self-contained toolchain with the necessary object files
	for prefix in prefix-s prefix-2 prefix; do
		SELF_CONTAINED=$RUN_RUSTC_OUTPUT/$prefix/lib/rustlib/${TARGET}/lib/self-contained/
		mkdir -p $SELF_CONTAINED
		for file in rcrt1.o crti.o crtn.o; do
			cp /usr/lib/$file $SELF_CONTAINED
		done
		for file in crtbeginS.o crtendS.o; do
			cp /usr/lib/gcc/${ARCH}-linux-musl/$(gcc -dumpversion)/$file $SELF_CONTAINED
		done
	done

	# We also use `gcc` here due to _some_ issue finding the necessary object files...
	export CC=gcc
	make -C run_rustc
	export CC=clang

	mkdir /rust-${RUSTC_VERSION}
	cp -R run_rustc/output/prefix /rust-${RUSTC_VERSION}/usr
EOF

WORKDIR /

ENV CONFIGURE_FLAGS=
COPY --chmod=0755 <<-'EOF' build
	set -eux
	TARGET_VERSION=${1}
	BUILD_VERSION=${2}
	TOOLS=${3:-cargo}
	PATCHES=${4:-}
	PREFIX=/rust-${TARGET_VERSION}/usr
	BUILD_PREFIX=/rust-${BUILD_VERSION}/usr
	export CC=${LLVM_BINDIR}/clang
	export CXX=${LLVM_BINDIR}/clang++
	export AS=${LLVM_BINDIR}/llvm-as
	export AR=${LLVM_BINDIR}/llvm-ar
	export NM=${LLVM_BINDIR}/llvm-nm
	export DWP=${LLVM_BINDIR}/llvm-dwp
	export RANLIB=${LLVM_BINDIR}/llvm-ranlib
	export READELF=${LLVM_BINDIR}/llvm-readelf
	export STRIP=${LLVM_BINDIR}/llvm-strip
	export OBJCOPY=${LLVM_BINDIR}/llvm-objcopy
	export OBJDUMP=${LLVM_BINDIR}/llvm-objdump
	export SIZE=${LLVM_BINDIR}/llvm-size
	export LIBCC="/usr/lib/clang/$($CC -dumpversion | cut -d'.' -f1)/lib/${TARGET}/libclang_rt.builtins.a"
	export LDFLAGS="-fuse-ld=/usr/bin/ld.mold"
	ln -sf ${LLVM_BINDIR}/clang++ /usr/bin/c++
	ln -sf ${LLVM_BINDIR}/clang /usr/bin/cc
	ln -sf /usr/bin/mold /usr/bin/ld
	cd rustc-${TARGET_VERSION}-src
	[[ -z "$PATCHES" ]] || for name in ${PATCHES//,/ }; do
		patch -p1 < ../${name}.patch
	done

	# Tune how `rustc` is built for a faster build process.
	#
	# - `embed-bitcode-false` doesn't emit LLVM bitcode with the object files, as unnecessary.
	# - `incremental=false` doesn't build a cache for incremental builds, as unnecessary here.
	RUSTFLAGS="-Clinker=clang -Clink-arg=-Wl,-fuse-ld=mold -Cembed-bitcode=false -Cincremental=false"
	# For intermediary compilers, which aren't part of the committed output, be more aggressive
	if [ ! "$TARGET_VERSION" = "$VERSION" ]; then
		# Enable native codegen
		RUSTFLAGS="$RUSTFLAGS -Ctarget-cpu=native"

		# Set `codegen-units` to `nproc`, which will break reproducible builds as Rust builds are only
		# deterministic with a consistent amount of units.
		RUSTFLAGS="$RUSTFLAGS -Ccodegen-units=$(nproc)"

		# Also, if the compiler is sufficiently modern, enable the threaded frontend. This was available
		# under nightly as soon ~1.75, but we delay enabling it until it was more tested and stable.
		# Note the usage of threads produces a non-deterministic output without flags such as
		# `-Zcodegen-source-order` to sort the outputs after their compilation.
		if [ $(printf "%s" "$BUILD_VERSION" | cut -d'.' -f2) -ge 85 ]; then
			RUSTFLAGS="$RUSTFLAGS -Zthreads=$(nproc)"
		fi
	fi

	./configure \
		--build="${TARGET}" \
		--host="${TARGET}" \
		--target="${TARGET}" \
		--local-rust-root="${BUILD_PREFIX}" \
		--tools="${TOOLS}" \
		--llvm-root="${LLVM_ROOT}" \
		--llvm-libunwind="system" \
		--enable-local-rust \
		--enable-clang \
		--enable-option-checking \
		--enable-locked-deps \
		--enable-vendor \
		--dist-compression-formats=gz \
		--disable-docs \
		--python="python3" \
		--prefix="${PREFIX}/usr" \
		--sysconfdir="${PREFIX}/etc" \
		--release-channel="stable" \
		--set="install.prefix=${PREFIX}" \
		--set="target.${TARGET}.crt-static=false" \
		--set="target.${TARGET}.musl-root=/usr" \
		--set="target.${TARGET}.llvm-config=${LLVM_BINDIR}/llvm-config" \
		--set="rust.optimize=2" \
		--set="rust.lld=false" \
		--set="rust.llvm-tools=false" \
		$CONFIGURE_FLAGS

	if [ ! "${TARGET_VERSION}" = "${VERSION}" ]; then
		# We only build the first-stage Rust compiler, as sufficient for further bootstrapping.
		#
		# We specifically choose `library`, as in, the Rust standard library, as what to build up to.
		#
		# The exception is with more modern compilers, due to the bootstrap sequence changing such that
		# `std` is only built _after_ the stage 1 compiler, requiring building the stage 1 compiler,
		# then `std`, then the stage 2 compiler, then `std` again, to create a functional sysroot.
		#
		# For more context on the changes made, see
		# https:/blog.rust-lang.org/inside-rust/2025/05/29/redesigning-the-initial-bootstrap-sequence.
		STAGE=1
		if [ $(printf "%s" "$TARGET_VERSION" | cut -d'.' -f2) -ge 90 ]; then
			STAGE=2
		fi
		python3 x.py build --stage $STAGE library

		# We also build `cargo`, as required to continue the bootstrap.
		#
		# We specify to build with the prior-stage toolchain, as acceptable, as building with the
		# just-built toolchain causes Rust's bootstrap to try to flush it out _much_ more.
		python3 x.py build --stage $(( $STAGE - 1 )) src/tools/cargo

		# Manually 'install' it
		mkdir -p ${PREFIX}
		mv build/host/stage${STAGE}/* ${PREFIX}/
		mv $(find build/host/ -type f -name "cargo" | head -n1) ${PREFIX}/bin/
	else
		python3 x.py install
	fi

	cd /
	[ "${TARGET_VERSION}" == "${VERSION}" ] || rm -rf rustc-${TARGET_VERSION}-src /rust-${BUILD_VERSION}
EOF

ADD fetch/rustc-1.91.1-src.tar.gz .
RUN --network=none ./build 1.91.1 1.90.0 ""

ADD fetch/rustc-1.92.0-src.tar.gz .
RUN --network=none ./build 1.92.0 1.91.1 ""

ADD fetch/rustc-1.93.1-src.tar.gz .

# Patch the default for `musl` targets to be dynamically, not statically, linked
RUN --network=none <<-EOF
	for file in $(find ./rustc-${VERSION}-src/compiler/rustc_target/src/spec/targets/ -type f | grep "musl"); do
		sed -i s/"crt_static_default = true"/"crt_static_default = false"/ $file
	done
EOF

RUN --network=none ./build ${VERSION} 1.92.0 cargo,clippy,rustdoc,rustfmt,rust-demangler,src,wasm-component-ld
RUN --network=none <<-EOF
	mv /rust-${VERSION} /rootfs
	cd /rootfs/usr/lib/rustlib
	rm install.log
	sort -o manifest-cargo manifest-cargo
	sort -o manifest-rustc manifest-rustc
	sort -o manifest-rust-std-${TARGET} manifest-rust-std-${TARGET}
	rm -f ${TARGET}/lib/self-contained/libunwind.a
EOF

FROM stagex/core-filesystem AS package-rust
COPY --from=build /rootfs/ /
